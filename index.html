<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Interactive RDF Graph Visualizer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- Include full d3 library first -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Then include d3-scale-chromatic -->
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <style>
      #content {
        height: calc(100vh - 56px); /* Adjust height based on navbar height */
      }
      #contentrow {
        height: 100%; /* Set row height to 100% of the container */
        overflow: auto; /* Manage overflow content */
      }
      #sidebar {
          transition: margin 0.3s;
      }
      .sidebar.hidden {
        transform: translateX(-250px);
        margin-left: -250px; /* Adjust this value based on your sidebar width */
      }
      
      .container-fluid.expanded {
        margin-left: 0;
      }
  
      /* Legend styling – fixed to lower right of the viewport */
      #legend {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 220px;
        max-height: 300px; /* if you wish, keep a max-height */
        overflow: auto;
        z-index: 1001;
        cursor: move;
        resize: both; /* enable browser native resize if supported */
      }
      
      #legendResizeHandle {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 15px;
        height: 15px;
        cursor: se-resize;
        background: rgba(0, 0, 0, 0.2);
      }
      
      
  
      #legend .legend-item {
        display: flex;
        flex-direction: column;
        padding: 2px 5px;
        border-bottom: 1px solid #eee;
      }
  
      #legend .legend-item:last-child {
        border-bottom: none;
      }
  
      #legend .legend-color {
        display: inline-block;
        width: 15px;
        height: 15px;
        margin-right: 5px;
        border: 1px solid #000;
      }
  
      /* Configuration Box Styling */
      #configBox {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 300px;
        background-color: #ffffff;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 1001;
        display: none; /* Hidden by default */
        flex-direction: column;
      }
  
      #configBox.hidden {
        height: 40px;
        overflow: hidden;
      }
  
      #configBoxHeader {
        background-color: #f1f1f1;
        padding: 10px;
        cursor: move;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #dee2e6;
      }
  
      #configBoxContent {
        padding: 10px;
        overflow-y: auto;
        max-height: 400px; /* Set a maximum height */
      }
  
      #minimizeBtn {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
      }
      #mainContent {
        position: relative;
      }
      /* Adjust graph container to account for floating boxes */
      #graphContainer {
        height: calc(100vh - 56px);
        width: 100%;
        position: relative;
      }
      
      @media (max-width: 767.98px) {
        #mainContent {
          margin-top: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <div class="container-fluid">
        <button id="toggleSidebar" class="btn btn-sm me-2">☰</button>
        <a class="navbar-brand" href="#">Interactive RDF Graph Visualizer</a>
        <div class="ms-auto">
          <button id="toggleLegend" class="btn btn-secondary btn-sm ms-2">Legend</button>
          <button id="toggleConfigBox" class="btn btn-secondary btn-sm">Physics</button>
        </div>
      </div>
    </nav>
    <div class="container-fluid" id="content">
        <div class="row" id="contentrow">
            <!-- Sidebar -->
            <div class="sidebar col-12 col-md-3 col-xl-2 px-0 bg-light d-flex flex-column" id="sidebar">
              <h5>RDF Graph Visualizer</h5>
              <hr />
              <!-- Input Source -->
              <div class="mb-3">
                <label class="form-label">Input Source</label>
                <div class="form-check">
                  <input class="form-check-input" type="radio" name="inputType" id="fileInputRadio" checked />
                  <label class="form-check-label" for="fileInputRadio">Load from File</label>
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="radio" name="inputType" id="sparqlInputRadio" />
                  <label class="form-check-label" for="sparqlInputRadio">Load from SPARQL Endpoint</label>
                </div>
              </div>
              <!-- File Input Section -->
              <div id="fileSection" class="mb-3">
                <input type="file" id="fileInput" accept=".ttl,.txt" class="form-control" />
                <button id="loadFileButton" class="btn btn-primary btn-sm mt-2">Load RDF Graph</button>
                
                <div class="mt-3">
                  <label class="form-label">Or enter file URL:</label>
                  <input type="text" id="fileUrlInput" placeholder="http://example.org/data.ttl" value="https://raw.githubusercontent.com/Mat-O-Lab/IOFMaterialsTutorial/refs/heads/main/sieving_ASTM_B214-07.ttl" class="form-control" />
                  <button id="loadFileUrlButton" class="btn btn-primary btn-sm mt-2">Load RDF from URL</button>
                </div>
              </div>                
              <!-- SPARQL Input Section -->
              <div id="sparqlSection" class="mb-3" style="display: none;">
                <div class="mb-2">
                  <label for="endpointUrl" class="form-label">Endpoint URL:</label>
                  <input type="text" id="endpointUrl" class="form-control" placeholder="https://example.org/sparql" />
                </div>
                <div class="mb-2">
                  <label for="sparqlQuery" class="form-label">SPARQL Query (CONSTRUCT):</label>
                  <textarea id="sparqlQuery" class="form-control" rows="3">
        CONSTRUCT { ?s ?p ?o } WHERE { ?s ?p ?o } LIMIT 100
                  </textarea>
                </div>
                <button id="loadSparqlButton" class="btn btn-primary btn-sm">Load SPARQL Graph</button>
              </div>
              <hr />
              <!-- Layout & Display Options -->
              <div class="mb-3">
                <h6>Layout Options</h6>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="disableImprovedLayout" />
                  <label class="form-check-label" for="disableImprovedLayout">Disable Improved Layout</label>
                </div>
                <div class="mb-2">
                  <label for="layoutType" class="form-label">Layout Type:</label>
                  <select id="layoutType" class="form-select form-select-sm">
                    <option value="force">Force Directed</option>
                    <option value="hierarchical" selected>Hierarchical</option>
                  </select>
                </div>
                <div class="mb-2">
                  <label for="connectionStyle" class="form-label">Connection Style:</label>
                  <select id="connectionStyle" class="form-select form-select-sm">
                    <option value="curved" selected>Curved</option>
                    <option value="straight">Straight</option>
                  </select>
                </div>
                <div class="mb-2">
                  <label for="physicsModel" class="form-label">Physics Model:</label>
                  <select id="physicsModel" class="form-select form-select-sm">
                    <option value="barnesHut">Barnes-Hut</option>
                    <option value="forceAtlas2Based">Force Atlas 2 Based</option>
                    <option value="repulsion">Repulsion</option>
                    <option value="hierarchicalRepulsion">Hierarchical Repulsion</option>
                    <option value="disabled" selected>Disabled</option>
                  </select>
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="hideIsolatedNodes" checked />
                  <label class="form-check-label" for="hideIsolatedNodes">Hide Isolated Nodes</label>
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="displayEdgeLabels" checked />
                  <label class="form-check-label" for="displayEdgeLabels">Display Edge Labels</label>
                </div>
                <div class="d-flex flex-wrap gap-1 mt-2">
                  <button id="expandAllButton" class="btn btn-secondary btn-sm">Expand All</button>
                  <button id="resetViewButton" class="btn btn-secondary btn-sm">Reset View</button>
                  <button id="exportSVGButton" class="btn btn-secondary btn-sm">Export SVG</button>
                  <button id="exportDOTButton" class="btn btn-secondary btn-sm">Export DOT</button>
                </div>
              </div>
              <hr />
              <footer class="mt-auto">
                <small>
                  Source code available at
                  <a href="https://github.com/ThHanke/rdfVis" target="_blank">GitHub</a>
                </small>
              </footer>
            </div>

            <!-- Main Content -->
            <main class="col-12 col-md-9 col-xl-10 px-4" id="mainContent">
              <div id="errorContainer" class="text-danger w-100"></div>
              <div id="contentArea">
                <!-- Graph Container -->
                <div id="graphContainer" class="mt-3">
                  <!-- Graph renders here -->
                </div>
                <!-- Configuration Box floating at top left -->
                <div id="configBox">
                  <div id="configBoxHeader">
                    <span>Configuration</span>
                    <button id="minimizeBtn">&minus;</button>
                  </div>
                  <div id="configBoxContent">
                    <!-- vis-network configuration controls will appear here -->
                  </div>
                </div>
                <!-- Moveable Legend Box -->
                <div id="legend" class="card">
                  <div class="card-header">Legend</div>
                  <ul class="list-group list-group-flush" id="legendList"></ul>
                  <div id="legendResizeHandle"></div>
                </div>
              </div>
            </main>
        </div>
    </div>
		<!-- Bootstrap Bundle with Popper -->
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
		<!-- vis-network -->
		<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
		<!-- rdflib -->
		<script src="https://unpkg.com/rdflib@2.2.4/dist/rdflib.min.js"></script>

    <script>
      // Sidebar Toggle Functionality
    const toggleBtn = document.getElementById("toggleSidebar");
    const sidebar = document.getElementById("sidebar");
    const mainContent = document.getElementById("mainContent");

    toggleBtn.addEventListener("click", () => {
      sidebar.classList.toggle("hidden");
      mainContent.classList.toggle("expanded");
    });

    // Configuration Box Minimize/Restore Functionality
    const minimizeBtn = document.getElementById("minimizeBtn");
    const configBox = document.getElementById("configBox");
    const configBoxContent = document.getElementById("configBoxContent");
    let isConfigMinimized = false;

    minimizeBtn.addEventListener("click", () => {
      isConfigMinimized = !isConfigMinimized;
      if (isConfigMinimized) {
        configBox.classList.add("hidden");
        minimizeBtn.innerHTML = "+";
      } else {
        configBox.classList.remove("hidden");
        minimizeBtn.innerHTML = "&minus;";
      }
    });

    // Toggle Config Box from Navbar button
    document.getElementById("toggleConfigBox").addEventListener("click", () => {
      if (configBox.style.display === "none" || configBox.style.display === "") {
        configBox.style.display = "flex";
      } else {
        configBox.style.display = "none";
      }
    });

      // Make Configuration Box Draggable
      (function makeConfigBoxDraggable() {
        const header = document.getElementById("configBoxHeader");
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

      header.onmousedown = dragMouseDown;

      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }

      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        configBox.style.top = (configBox.offsetTop - pos2) + "px";
        configBox.style.left = (configBox.offsetLeft - pos1) + "px";
      }

      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    })();
    // Toggle legend visibility when the "Legend" button is clicked.
    document.getElementById("toggleLegend").addEventListener("click", function() {
      const legend = document.getElementById("legend");
      if (legend.style.display === "none" || legend.style.display === "") {
        legend.style.display = "block";
      } else {
        legend.style.display = "none";
      }
    });

    // Make legend resizable using the custom resize handle.
    (function makeLegendResizable() {
      const legend = document.getElementById("legend");
      const resizer = document.getElementById("legendResizeHandle");
      let startX, startY, startWidth, startHeight;

      resizer.addEventListener("mousedown", function(e) {
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        startWidth = parseInt(window.getComputedStyle(legend).width, 10);
        startHeight = parseInt(window.getComputedStyle(legend).height, 10);
        document.documentElement.addEventListener("mousemove", doDrag, false);
        document.documentElement.addEventListener("mouseup", stopDrag, false);
      });

      function doDrag(e) {
        legend.style.width = (startWidth + e.clientX - startX) + "px";
        legend.style.height = (startHeight + e.clientY - startY) + "px";
      }

      function stopDrag(e) {
        document.documentElement.removeEventListener("mousemove", doDrag, false);
        document.documentElement.removeEventListener("mouseup", stopDrag, false);
      }
    })();

    </script>
		<script>
			// Global variables
			var networkNodes = null;
			var networkEdges = null;
			var network = null;
			var store = $rdf.graph();
      var prefixNamespaceMapping = {};
			var knownPrefixes = {
				rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
				rdfs: "http://www.w3.org/2000/01/rdf-schema#",
				xsd: "http://www.w3.org/2001/XMLSchema#"
			};
      const excludePredicatestoCluster = ['rdf:type','rdfs:label','dcterms:','owl:'];
      const clusteringThreshold = 10;
			var generatedPrefixCounter = 1;
			var prefixNamespaceMapping = {}; // records all prefixes and their namespaces
      var prefixColorMapping = {};     // records the colors for each prefix
      // Keep track of each node's expansion state and base (shortened) label.
      
      var nodeState = {};
			
			var currentNodeRadius = 15;
			var currentFontSize = 10;

      function saveConfigOptions() {
        const config = {
          layoutType: document.getElementById("layoutType").value,
          physicsModel: document.getElementById("physicsModel").value,
          connectionStyle: document.getElementById("connectionStyle").value,
          hideIsolatedNodes: document.getElementById("hideIsolatedNodes").checked,
          displayEdgeLabels: document.getElementById("displayEdgeLabels").checked,
          disableImprovedLayout: document.getElementById("disableImprovedLayout").checked
        };
        localStorage.setItem("visNetworkConfig", JSON.stringify(config));
      }
      function loadConfigOptions() {
        const configStr = localStorage.getItem("visNetworkConfig");
        if (configStr) {
          const config = JSON.parse(configStr);
          document.getElementById("layoutType").value = config.layoutType || "hierarchical";
          document.getElementById("physicsModel").value = config.physicsModel || "disabled";
          document.getElementById("connectionStyle").value = config.connectionStyle || "curved";
          document.getElementById("hideIsolatedNodes").checked = config.hideIsolatedNodes;
          document.getElementById("displayEdgeLabels").checked = config.displayEdgeLabels;
          document.getElementById("disableImprovedLayout").checked = config.disableImprovedLayout;
        }
      }

			// Helper: Create an SVG element with attributes.
			function createSvgElement(tag, attrs) {
				var elem = document.createElementNS("http://www.w3.org/2000/svg", tag);
				for (var key in attrs) {
					elem.setAttribute(key, attrs[key]);
				}
				return elem;
			}

			// Helper: Wrap long labels into multiple lines.
			function wrapLabel(label, maxLength) {
        maxLength = maxLength || 15;
        if (label.length <= maxLength) return label;
        var words = label.split(" ");
        var lines = [];
        var currentLine = "";
        words.forEach(function (word) {
            if ((currentLine + word).length <= maxLength) {
                currentLine += word + " ";
            } else {
                if (currentLine.trim()) { // Check if currentLine is not empty
                    lines.push(currentLine.trim());
                }
                currentLine = word + " ";
            }
        });
        if (currentLine.trim()) { // Check if currentLine is not empty
            lines.push(currentLine.trim());
        }
        return lines.join("\n");
      }

			// Error display functions.
			function showError(message) {
				document.getElementById("errorContainer").innerText = message;
			}
			function clearError() {
				document.getElementById("errorContainer").innerText = "";
			}

			// Toggle input sections.
			document.getElementById("fileInputRadio").addEventListener("change", function () {
				document.getElementById("fileSection").style.display = "block";
				document.getElementById("sparqlSection").style.display = "none";
			});
			document.getElementById("sparqlInputRadio").addEventListener("change", function () {
				document.getElementById("fileSection").style.display = "none";
				document.getElementById("sparqlSection").style.display = "block";
			});
      

			// Shorten URI – if base defined, use "base:".
			function shortenURI(uri) {
        if (knownPrefixes["base"] && uri.indexOf(knownPrefixes["base"]) === 0) {
          return "base:" + uri.substring(knownPrefixes["base"].length);
        }
        // Filter out any undefined or non-string values.
        var entries = Object.entries(knownPrefixes)
          .filter(function ([p, ns]) {
            return ns && typeof ns === "string";
          })
          .map(function ([p, ns]) {
            return { prefix: (p === "" ? "base" : p), ns: ns };
          });
        entries.sort(function (a, b) {
          return b.ns.length - a.ns.length;
        });
        for (var i = 0; i < entries.length; i++) {
          var prefix = entries[i].prefix;
          var ns = entries[i].ns;
          if (uri.indexOf(ns) === 0) {
            return prefix + ":" + uri.substring(ns.length);
          }
        }
        var idx = Math.max(uri.lastIndexOf("/"), uri.lastIndexOf("#"));
        if (idx === -1) return uri;
        var ns = uri.substring(0, idx + 1);
        var local = uri.substring(idx + 1);
        for (var key in knownPrefixes) {
          if (knownPrefixes[key] === ns) {
            var pfx = (key === "" ? "base" : key);
            return pfx + ":" + local;
          }
        }
        var newPrefix = "ns" + generatedPrefixCounter++;
        knownPrefixes[newPrefix] = ns;
        return newPrefix + ":" + local;
      }
            
      function shortenLabel(label) {
        if (typeof label !== 'string') {
          if (label && typeof label.value === 'string') {
            label = label.value;
          } else {
            console.error('Label is not a string:', label);
            return '[Invalid label]';
          }
        }
        if (label.startsWith("http://") || label.startsWith("https://")) {
          const shortened = shortenURI(label);
          // Check if the shortened version ends with a colon
          if (shortened.endsWith(':')) {
            return label; // Return the original label
          }
          return shortened; // Return the shortened version
        }
        return label;
      }
			// Parse RDF using rdflib (Turtle)
			function parseRDF(data, baseUrl, contentType) {
        return new Promise(function (resolve, reject) {
          store = $rdf.graph();
          // Reset knownPrefixes to avoid stale or undefined values.
          knownPrefixes = {
            rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
            rdfs: "http://www.w3.org/2000/01/rdf-schema#",
            xsd: "http://www.w3.org/2001/XMLSchema#"
          };
          $rdf.parse(data, store, baseUrl, contentType, function (err) {
            if (err) {
              console.error("Error parsing RDF:", err);
              return reject(new Error("Error parsing RDF: " + err.message));
            }
            try {
              if (store.namespaces) {
                if (store.namespaces[""]) {
                  knownPrefixes["base"] = store.namespaces[""];
                }
                for (var prefix in store.namespaces) {
                  if (store.namespaces.hasOwnProperty(prefix)) {
                    let ns = store.namespaces[prefix];
                    // Ensure ns is defined and a string before assignment.
                    if (ns && typeof ns === "string" && !knownPrefixes[prefix]) {
                      knownPrefixes[prefix] = ns;
                    }
                  }
                }
              }
              resolve(store);
            } catch (ex) {
              console.error("Exception during RDF processing:", ex);
              reject(new Error("Exception during RDF processing: " + ex.message));
            }
          });
        });
      }

      // Helper function to perform fetch with a timeout.
      function fetchWithTimeout(url, options = {}, timeout = 10000) {
        return new Promise((resolve, reject) => {
          const controller = new AbortController();
          const timer = setTimeout(() => {
            controller.abort();
            reject(new Error("Request timed out"));
          }, timeout);

          fetch(url, { ...options, signal: controller.signal })
            .then(response => {
              clearTimeout(timer);
              resolve(response);
            })
            .catch(err => {
              clearTimeout(timer);
              reject(err);
            });
        });
      }

      function loadFromURL(sourceUrl) {
        if (sourceUrl) {
          fetchWithTimeout(sourceUrl, {}, 10000)
            .then(response => {
              if (!response.ok) {
                console.log(response)
                throw new Error("Network response was not ok: " + response.statusText);
              }
              return response.text();
            })
            .then(data => {
              localStorage.setItem("rdfData", data);
              parseRDF(data, sourceUrl, "text/turtle")
                .then(store => {
                  const graphData = buildGraphFromStore(store);
                  assignColors(graphData.nodes);
                  renderNetwork(graphData);
                })
                .catch(err => {
                  console.error("Error parsing RDF from source URL:", err);
                });
            })
            .catch(err => {
              console.error("Error fetching RDF file from source URL:", err);
            });
        }
      }
      // Load RDF data from URL parameters (source for file, sparql for SPARQL endpoint).
      function loadFromURLParameters() {
        const params = new URLSearchParams(window.location.search);
        const sourceUrl = params.get("source");
        const sparqlUrl = params.get("sparql");

        if (sourceUrl) {
          loadFromURL(sourceUrl);
        }

        if (sparqlUrl) {
          const sparqlQuery = params.get("query") || "CONSTRUCT { ?s ?p ?o } WHERE { ?s ?p ?o } LIMIT 100";
          fetchWithTimeout(sparqlUrl, {
            method: "POST",
            headers: { "Content-Type": "application/sparql-query", "Accept": "text/turtle" },
            body: sparqlQuery
          }, 10000)
            .then(response => {
              if (!response.ok) {
                throw new Error("Network response was not ok: " + response.statusText);
              }
              return response.text();
            })
            .then(data => {
              parseRDF(data, sparqlUrl, "text/turtle")
                .then(store => {
                  const graphData = buildGraphFromStore(store);
                  assignColors(graphData.nodes);
                  renderNetwork(graphData);
                })
                .catch(err => {
                  console.error("Error parsing RDF from SPARQL URL:", err);
                });
            })
            .catch(err => {
              console.error("Error fetching SPARQL data from URL parameter:", err);
            });
        }
      }

      function getNodeId(node) {
        if (node.termType === 'NamedNode') {
          return node.value;
        } else if (node.termType === 'BlankNode') {
          // Use a custom prefix that avoids the ":" syntax
          return "blank" + node.id;
        } else if (node.termType === 'Collection') {
          // Use a custom prefix that avoids the ":" syntax
          return "collection" + node.id;
        } else {
          console.error('Unsupported node termType:', node.termType);
          return "unknown";
        }
      }

      function NodeTitle(title,subtitle = "") {
        // Start with the bold title
        let result = "<b>" + title + "</b>";
        
        // Check if the subtitle is not empty
        if (subtitle) {
            // Add a newline and the subtitle if it is not empty
            result += "\n" + subtitle;
        }
        return result;
      }


			// Build graph from store.
			function buildGraphFromStore(store) {
        var nodesMap = {};
        var edges = [];
        var edgeIdCounter = 0;
      
        store.statements.forEach(function (st) {
          const subjId = getNodeId(st.subject);
          const pred = st.predicate.value;
          const objId = st.object.termType === 'Literal' ? null : getNodeId(st.object);
        
          // Handle rdfs:label
          if (pred === 'http://www.w3.org/2000/01/rdf-schema#label') {
            if (!nodesMap[subjId]) {
              nodesMap[subjId] = {
                id: subjId,
                font: { multi: true },
                label:  NodeTitle(shortenLabel(subjId),st.object.value)+ ' [-]',
                shape: 'box'
              };
              nodeState[subjId] = { expanded: true, baseLabel: NodeTitle(shortenLabel(subjId),st.object.value) };
            } else {
              nodesMap[subjId].font= { multi: true };
              nodesMap[subjId].label = NodeTitle(shortenLabel(subjId),st.object.value)+ ' [-]';
              nodeState[subjId].baseLabel = NodeTitle(shortenLabel(subjId),st.object.value);
            }
            return;
          }
        
          // Handle rdf:type
          if (pred === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
            if (!nodesMap[subjId]) {
              nodesMap[subjId] = {
                id: subjId,
                font: { multi: true },
                label: NodeTitle(shortenLabel(subjId))+ ' [-]',
                shape: 'box',
                type: st.object.value
              };
              nodeState[subjId] = { expanded: true, baseLabel: NodeTitle(shortenLabel(subjId)) };
            } else {
              nodesMap[subjId].type = st.object.value;
            }
            return;
          }
        
          // Process other predicates
          // Add subject node if not exists
          if (!nodesMap[subjId]) {
            nodesMap[subjId] = {
              id: subjId,
              font: { multi: true },
              label: NodeTitle(shortenLabel(subjId))+ ' [-]',
              shape: 'box'
            };
            nodeState[subjId] = { expanded: true, baseLabel: NodeTitle(shortenLabel(subjId)) };
          }
        
          // Add object node
          let objLabel;
          let objNodeId;
          if (st.object.termType === 'Literal') {
            // Handle literals by creating a unique ID
            objNodeId = subjId + '-' + pred + '-literal-' + edgeIdCounter;
            objLabel = st.object.value;
            nodesMap[objNodeId] = {
              id: objNodeId,
              label: objLabel,
              shape: 'box'
            };
          } else {
            objNodeId = objId;
            if (!nodesMap[objNodeId]) {
              nodesMap[objNodeId] = {
                id: objNodeId,
                font: { multi: true },
                label: NodeTitle(shortenLabel(objNodeId))+ ' [-]',
                shape: 'box'
              };
              nodeState[objNodeId] = { expanded: true, baseLabel: NodeTitle(shortenLabel(objNodeId)) };
            }
          }
        
          // Add edge
          edges.push({
            id: 'edge-' + edgeIdCounter++,
            from: subjId,
            to: objNodeId,
            label: shortenLabel(pred),
            arrows: { to: { enabled: true, type: 'arrow' } }
          });
        });
      
        // Convert nodesMap to array
        var nodesArray = Object.values(nodesMap);
      
        return { nodes: nodesArray, edges: edges };
      }
      
			// Color nodes based on their rdf:type namespace.
      function assignColors(nodes) {
        // Use a ColorBrewer qualitative palette from d3-scale-chromatic:
        var palette = d3.schemeSet2; // an array of colors
        var localPrefixColor = {};
        var colorIndex = 0;
        // Build the mapping from all prefixes in knownPrefixes
        for (var prefix in knownPrefixes) {
          localPrefixColor[prefix] = palette[colorIndex % palette.length];
          colorIndex++;
        }
      
        nodes.forEach(function(node) {
          // Ensure node.type is defined and valid
          if (node.type && typeof node.type === 'string' && (node.type.startsWith('http://') || node.type.startsWith('https://'))) {
            // Find the best matching prefix from knownPrefixes.
            var chosenPrefix = null;
            var chosenLength = 0;
            for (var prefix in knownPrefixes) {
              var ns = knownPrefixes[prefix];
              if (node.type.indexOf(ns) === 0 && ns.length > chosenLength) {
                chosenPrefix = prefix;
                chosenLength = ns.length;
              }
            }
            if (chosenPrefix) {
              node.color = { background: localPrefixColor[chosenPrefix], border: "#000" };
              // node.title is already set in buildGraphFromStore
            } else {
              node.color = { background: "#CCCCCC", border: "#000" };
              // node.title is already set in buildGraphFromStore
            }
          } else {
            node.color = { background: "#CCCCCC", border: "#000" };
            // node.title is already set in buildGraphFromStore
          }
          // Construct tooltip string with all properties
          var tooltipContent = Object.entries(node)
            .filter(([key]) => key !== 'shape' && key !== 'color') // Exclude 'shape' and 'color'
            .map(([key, value]) => `${key}: ${value}`)
            .join("\n");

          // Set the title property for the tooltip
          node.title = tooltipContent;
        });
      
        // Save the mapping globally so updateLegend can use it.
        prefixColorMapping = localPrefixColor;
        updateLegend();
      }
      

      // Update the legend – now showing full namespace under each prefix.
      function updateLegend() {
        var legendList = document.getElementById("legendList");
        legendList.innerHTML = "";
        for (var prefix in prefixColorMapping) {
          var li = document.createElement("li");
          li.className = "list-group-item legend-item";
          li.innerHTML =
            '<div style="display:flex; align-items:center;">' +
              '<span class="legend-color" style="background:' + prefixColorMapping[prefix] + ';"></span>' +
              '<strong>' + prefix + '</strong>' +
            '</div>' +
            '<div style="font-size:smaller; color:#555;">' + knownPrefixes[prefix] + '</div>';
          legendList.appendChild(li);
        }
      }
      
			// Render network with options.
			function renderNetwork(graphData) {
        var hideIsolated = document.getElementById("hideIsolatedNodes").checked;
        var displayEdgeLabels = document.getElementById("displayEdgeLabels").checked;
        var connectedIds = new Set();
        graphData.edges.forEach(function (edge) {
					if (!displayEdgeLabels) edge.label = "";
          connectedIds.add(edge.from);
          connectedIds.add(edge.to);
        });
        if (hideIsolated) {  
          graphData.nodes = graphData.nodes.filter(function (n) { return connectedIds.has(n.id); });
        }
				
        currentNodeRadius = 15;
				currentFontSize = 10;
				var layoutType = document.getElementById("layoutType").value;
				var physicsModel = document.getElementById("physicsModel").value;
				var displayEdgeLabels = document.getElementById("displayEdgeLabels").checked;
				var layoutOption = layoutType === "hierarchical" ?
					{ hierarchical: {
            enabled: true,
            levelSeparation: 150,
            nodeSpacing: 100,
            treeSpacing: 200,
            blockShifting: true,
            edgeMinimization: true,
            parentCentralization: true,
            direction: 'UD',        // UD, DU, LR, RL
            sortMethod: 'hubsize',  // hubsize, directed
            shakeTowards: 'leaves'  // roots, leaves
          },
            improvedLayout: !document.getElementById("disableImprovedLayout").checked } :
					{ improvedLayout: !document.getElementById("disableImprovedLayout").checked };
				var physicsOption = {};
				var connectionStyle = document.getElementById("connectionStyle").value;
				var smoothOption = connectionStyle === "curved" ? { enabled: true, type: "continuous" } : false;
				var options = {
					layout: layoutOption,
					physics: physicsOption,
					interaction: { hover: true },
					edges: { smooth: smoothOption },
					nodes: {
						widthConstraint: { maximum: 100 },
						font: { multi: true, size: currentFontSize },
						shapeProperties: { useImageSize: false }
					}
				};
        console.log(options)
				networkNodes = new vis.DataSet(graphData.nodes);
				networkEdges = new vis.DataSet(graphData.edges);
				networkNodes.forEach(function (node) {
					node.size = currentNodeRadius;
					networkNodes.update(node);
				});
        
				if (network) network.destroy();
				network = new vis.Network(document.getElementById("graphContainer"), { nodes: networkNodes, edges: networkEdges }, options);
				network.on("doubleClick", function (params) {
          if (params.nodes.length === 1) {
            const nodeId = params.nodes[0];
            if (network.isCluster(nodeId)) {
              network.openCluster(nodeId);
            } else {
              toggleNode(nodeId);
            }
          }
        });

        // Apply clustering
        applyClusteringByPredicate();
        applyEdgeFormat();
        applyLayoutPhysics();
			}

      function renderGraph() {
        const graphData = buildGraphFromStore(store);
	  		assignColors(graphData.nodes);
		  	renderNetwork(graphData);
      }
      function initializeNetwork() {
        const container = document.getElementById("graphContainer");
        const configBoxContent = document.getElementById("configBoxContent");
        const options = {
          layout: { hierarchical: { enabled: false, direction: "LR"} },
          physics: {
            enabled: true,
            solver: "barnesHut",
            barnesHut: {
              theta: 0.5,
              gravitationalConstant: -2000,
              centralGravity: 0.3,
              springLength: 95,
              springConstant: 0.04,
              damping: 0.09,
              avoidOverlap: 0
            },
            stabilization: { enabled: true, iterations: 1000, updateInterval: 100, fit: true }
          },
          interaction: { hover: true },
          edges: { smooth: false },
          nodes: {
            widthConstraint: { maximum: 100 },
            font: { multi: true, size: currentFontSize },
            shapeProperties: { useImageSize: false }
          },
          configure: {
            enabled: true,
            filter: ["physics"],
            showButton: false,
            container: configBoxContent, // Render config controls inside configBoxContent
          },
        };
        network = new vis.Network(container, { nodes: new vis.DataSet(), edges: new vis.DataSet() }, options);
      }
      
      // List of predicates to include in clustering
      
      function applyClusteringByPredicate() {
        const predicateLabels = new Set();

        networkEdges.get().forEach(edge => {
          if (edge.label) {
            // Include only predicates in the includedPredicates array
            if (excludePredicatestoCluster.some(pred => edge.label.includes(pred))) return;
            predicateLabels.add(edge.label);
          }
        });

        predicateLabels.forEach(predicateLabel => {
          clusterNodesByPredicate(predicateLabel);
        });
      }
      
      function clusterNodesByPredicate(predicateLabel) {
        const clusterOptions = {
          joinCondition: function(nodeOptions) {
            const connectedEdges = network.getConnectedEdges(nodeOptions.id);
            const count = connectedEdges.filter(edgeId => {
              const edge = network.body.data.edges.get(edgeId);
              return edge.label === predicateLabel;
            }).length;
            // Only include nodes with connections exceeding the threshold
            return count > clusteringThreshold;
          },
          processProperties: function(clusterOptions, childNodes, childEdges) {
            clusterOptions.label = predicateLabel + "\n(" + childNodes.length + " nodes)";
            clusterOptions.shape = "circle";
            clusterOptions.color = { background: '#FFC107', border: '#FF9800' }; // Customize color
            clusterOptions.title = "Cluster of nodes connected via predicate: " + predicateLabel;
            return clusterOptions;
          },
          clusterNodeProperties: { id: 'cluster:' + predicateLabel, borderWidth: 3, shape: 'circle' }
        };
      
        network.cluster(clusterOptions);
      }
			// Toggle node expansion/collapse
			function toggleNode(nodeId) {
        var state = nodeState[nodeId];
        if (!state) return;

        if (state.expanded) {
          collapseNode(nodeId);
          state.expanded = false;
          network.body.data.nodes.update({ id: nodeId, label: state.baseLabel + " [+]" });
        } else {
          expandNode(nodeId);
          state.expanded = true;
          network.body.data.nodes.update({ id: nodeId, label: state.baseLabel + " [-]" });
        }
      }

			function collapseNode(nodeId) {
        // Fetch all outgoing edges from this node
        var connectedEdges = network.getConnectedEdges(nodeId);
      
        connectedEdges.forEach(function(edgeId) {
          var edge = network.body.data.edges.get(edgeId);
          if (edge.from === nodeId) {
            // Hide the edge
            network.body.data.edges.update({ id: edgeId, hidden: true });
            // Hide the connected node if it's not connected elsewhere
            var connectedNodeId = edge.to;
      
            // Check if the connected node has other visible incoming edges
            var incomingEdges = network.getConnectedEdges(connectedNodeId).filter(function(eid) {
              var e = network.body.data.edges.get(eid);
              return e.to === connectedNodeId && !e.hidden && e.from !== nodeId;
            });
      
            if (incomingEdges.length === 0) {
              // Recursively collapse the connected node
              collapseNode(connectedNodeId);
              network.body.data.nodes.update({ id: connectedNodeId, hidden: true });
              // Ensure nodeState exists before updating
              if (nodeState[connectedNodeId]) {
                nodeState[connectedNodeId].expanded = false;
              }
            }
          }
        });
      }

			function expandNode(nodeId) {
        // Fetch all outgoing edges from this node
        var connectedEdges = network.getConnectedEdges(nodeId);
      
        connectedEdges.forEach(function(edgeId) {
          var edge = network.body.data.edges.get(edgeId);
          if (edge.from === nodeId) {
            // Show the edge
            network.body.data.edges.update({ id: edgeId, hidden: false });
            // Show the connected node
            var connectedNodeId = edge.to;
            network.body.data.nodes.update({ id: connectedNodeId, hidden: false });
          }
        });
      }

			// Make legend draggable
			(function makeLegendDraggable() {
				var legend = document.getElementById("legend");
				var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
				legend.onmousedown = dragMouseDown;
				function dragMouseDown(e) {
					e = e || window.event;
					e.preventDefault();
					pos3 = e.clientX;
					pos4 = e.clientY;
					document.onmouseup = closeDragElement;
					document.onmousemove = elementDrag;
				}
				function elementDrag(e) {
					e = e || window.event;
					e.preventDefault();
					pos1 = pos3 - e.clientX;
					pos2 = pos4 - e.clientY;
					pos3 = e.clientX;
					pos4 = e.clientY;
					legend.style.top = (legend.offsetTop - pos2) + "px";
					legend.style.left = (legend.offsetLeft - pos1) + "px";
				}
				function closeDragElement() {
					document.onmouseup = null;
					document.onmousemove = null;
				}
			})();

			// Export SVG helper function for element creation.
			function createSvgElement(tag, attrs) {
				var elem = document.createElementNS("http://www.w3.org/2000/svg", tag);
				for (var key in attrs) {
					elem.setAttribute(key, attrs[key]);
				}
				return elem;
			}

			// Export current view as SVG.
			function exportSVG() {
				const container = document.getElementById("graphContainer");
				const width = container.clientWidth;
				const height = container.clientHeight;
				const svgNS = "http://www.w3.org/2000/svg";
				const svgElem = createSvgElement("svg", { width: width, height: height, xmlns: svgNS });
				const defs = createSvgElement("defs", {});
				const marker = createSvgElement("marker", {
					id: "arrow",
					markerWidth: "10",
					markerHeight: "10",
					refX: "10",
					refY: "3",
					orient: "auto",
					markerUnits: "strokeWidth"
				});
				const arrowPath = createSvgElement("path", { d: "M0,0 L0,6 L9,3 z", fill: "#000" });
				marker.appendChild(arrowPath);
				defs.appendChild(marker);
				svgElem.appendChild(defs);
				const positions = network.getPositions();
				networkEdges.get().forEach(function (edge) {
					if (edge.hidden) return;
					const fromPos = positions[edge.from];
					const toPos = positions[edge.to];
					if (!fromPos || !toPos) return;
					const line = createSvgElement("line", {
						x1: fromPos.x,
						y1: fromPos.y,
						x2: toPos.x,
						y2: toPos.y,
						stroke: "#000",
						"stroke-width": "2",
						"marker-end": "url(#arrow)"
					});
					svgElem.appendChild(line);
					if (document.getElementById("displayEdgeLabels").checked && edge.label) {
						const midX = (fromPos.x + toPos.x) / 2;
						const midY = (fromPos.y + toPos.y) / 2;
						const text = createSvgElement("text", {
							x: midX,
							y: midY,
							"font-size": "10",
							fill: "#000",
							"text-anchor": "middle"
						});
						text.textContent = shortenLabel(edge.label);
						svgElem.appendChild(text);
					}
				});
				networkNodes.get().forEach(function (node) {
					if (node.hidden) return;
					const pos = positions[node.id];
					if (!pos) return;
					if (node.shape === "circle") {
						const radius = node.size || currentNodeRadius;
						const circle = createSvgElement("circle", {
							cx: pos.x,
							cy: pos.y,
							r: radius,
							fill: node.color && node.color.background ? node.color.background : "#CCCCCC",
							stroke: node.color && node.color.border ? node.color.border : "#000",
							"stroke-width": "2"
						});
						svgElem.appendChild(circle);
					} else {
						const rect = createSvgElement("rect", {
							x: pos.x - currentNodeRadius,
							y: pos.y - currentNodeRadius,
							width: currentNodeRadius * 2,
							height: currentNodeRadius * 2,
							fill: node.color && node.color.background ? node.color.background : "#CCCCCC",
							stroke: node.color && node.color.border ? node.color.border : "#000",
							"stroke-width": "2"
						});
						svgElem.appendChild(rect);
					}
					const text = createSvgElement("text", {
						x: pos.x,
						y: pos.y + 4,
						"font-size": currentFontSize,
						fill: "#000",
						"text-anchor": "middle"
					});
					text.textContent = nodeState[node.id] ? nodeState[node.id].baseLabel : node.label;
					svgElem.appendChild(text);
				});
				const legend = document.getElementById("legend");
				const legendRect = legend.getBoundingClientRect();
				const graphRect = document.getElementById("graphContainer").getBoundingClientRect();
				const legendGroup = createSvgElement("g", {});
				legendGroup.setAttribute("transform", `translate(${legendRect.left - graphRect.left}, ${legendRect.top - graphRect.top})`);
				const legendBg = createSvgElement("rect", {
					x: 0,
					y: 0,
					width: legendRect.width,
					height: legendRect.height,
					fill: "#fff",
					stroke: "#000"
				});
				legendGroup.appendChild(legendBg);
				const legendItems = document.getElementById("legendList").children;
				for (let i = 0; i < legendItems.length; i++) {
					const item = legendItems[i];
					const color = item.querySelector(".legend-color").style.background;
					const prefix = item.querySelector("strong").innerText;
					let ns = "";
					for (const k in knownPrefixes) {
						const displayKey = (k === "" ? "base" : k);
						if (displayKey === prefix) {
							ns = knownPrefixes[k];
							break;
						}
					}
					const colorRect = createSvgElement("rect", {
						x: 5,
						y: 5 + i * 25,
						width: 15,
						height: 15,
						fill: color,
						stroke: "#000"
					});
					legendGroup.appendChild(colorRect);
					const prefixText = createSvgElement("text", {
						x: 25,
						y: 17 + i * 25,
						"font-size": "10",
						fill: "#000"
					});
					prefixText.textContent = prefix;
					legendGroup.appendChild(prefixText);
					const nsText = createSvgElement("text", {
						x: 5,
						y: 25 + i * 25,
						"font-size": "8",
						fill: "#555"
					});
					nsText.textContent = ns;
					legendGroup.appendChild(nsText);
				}
				svgElem.appendChild(legendGroup);
				const serializer = new XMLSerializer();
				const svgString = serializer.serializeToString(svgElem);
				const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
				const url = URL.createObjectURL(blob);
				const downloadLink = document.createElement("a");
				downloadLink.href = url;
				downloadLink.download = "graph.svg";
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);
			}

			window.onload = function () {
        loadConfigOptions();
        initializeNetwork();
        window.scrollTo(0, 0);
      
        const savedData = localStorage.getItem("rdfData");
        if (savedData) {
          parseRDF(savedData, "http://example.org/", "text/turtle")
            .then(store => {
              const graphData = buildGraphFromStore(store);
              assignColors(graphData.nodes);
              renderNetwork(graphData);
            })
            .catch(err => showError("Error parsing RDF: " + err.message));
        }
        
        // Load from URL parameters if provided.
        loadFromURLParameters();
      };
      
      
      

			document.getElementById("loadFileButton").addEventListener("click", function () {
        clearError();
        const fileInput = document.getElementById("fileInput");
        if (fileInput.files.length === 0) {
          showError("Please select a file.");
          return;
        }
        const file = fileInput.files[0];
        const reader = new FileReader();
        reader.onerror = function (e) {
          showError("Error reading file: " + e.target.error.message);
        };
        reader.onload = function (e) {
          const data = e.target.result;
          // Save the RDF data so it persists on reload:
          localStorage.setItem("rdfData", data);
          parseRDF(data, "http://file.local/", "text/turtle")
            .then(function (store) {
              const graphData = buildGraphFromStore(store);
              assignColors(graphData.nodes);
              renderNetwork(graphData);
            })
            .catch(function (err) {
              showError("Error parsing RDF: " + err.message);
            });
        };
        reader.readAsText(file);
      });
      
      
			document.getElementById("loadSparqlButton").addEventListener("click", function () {
				clearError();
				const endpointUrl = document.getElementById("endpointUrl").value.trim();
				const query = document.getElementById("sparqlQuery").value.trim();
				if (!endpointUrl || !query) {
					showError("Please provide both an endpoint URL and a SPARQL query.");
					return;
				}
				fetch(endpointUrl, {
					method: "POST",
					headers: { "Content-Type": "application/sparql-query", "Accept": "text/turtle" },
					body: query
				})
					.then(function (response) {
						if (!response.ok) {
							throw new Error("Network response was not ok: " + response.statusText);
						}
						return response.text();
					})
					.then(function (data) {
						return parseRDF(data, endpointUrl, "text/turtle");
					})
					.then(function (store) {
						const graphData = buildGraphFromStore(store);
						assignColors(graphData.nodes);
						renderNetwork(graphData);
					})
					.catch(function (err) {
						showError("Error fetching or parsing SPARQL data: " + err.message);
					});
			});
      document.getElementById("loadFileUrlButton").addEventListener("click", function () {
        clearError();
        const fileUrl = document.getElementById("fileUrlInput").value.trim();
        if (!fileUrl) {
          showError("Please enter a file URL.");
          return;
        }
        loadFromURL(fileUrl);
      });
      
			//document.getElementById("layoutType").addEventListener("change", applyLayoutPhysics);
      //document.getElementById("physicsModel").addEventListener("change", applyLayoutPhysics);
      //document.getElementById("connectionStyle").addEventListener("change", renderGraph);
      //document.getElementById("hideIsolatedNodes").addEventListener("change", renderGraph);
      //document.getElementById("displayEdgeLabels").addEventListener("change", renderGraph);
			//document.getElementById("configBoxContent").addEventListener("change", function() {
        // Re-render the network with updated configuration values
      //  renderGraph();
      //});

      document.getElementById("layoutType").addEventListener("change", function() {
        saveConfigOptions();
        applyLayoutPhysics();
        renderGraph();
      });
    
      document.getElementById("physicsModel").addEventListener("change", function() {
        saveConfigOptions();
        renderGraph();
      });
    
      document.getElementById("connectionStyle").addEventListener("change", function() {
        saveConfigOptions();
        renderGraph();
      });
    
      document.getElementById("hideIsolatedNodes").addEventListener("change", function() {
        saveConfigOptions();
        renderGraph();
      });
    
      document.getElementById("displayEdgeLabels").addEventListener("change", function() {
        saveConfigOptions();
        renderGraph();
      });
    
      document.getElementById("disableImprovedLayout").addEventListener("change", function() {
        saveConfigOptions();
        renderGraph();
      });
    
      // Also save when the configuration box (generated by vis‑network) changes
      document.getElementById("configBoxContent").addEventListener("change", function() {
        syncConfigToSidebar();
        saveConfigOptions();
        renderGraph();
      });

      function applyEdgeFormat() {
        const displayEdgeLabels = document.getElementById("displayEdgeLabels").checked;
        if (!displayEdgeLabels) {
          network.body.data.edges.forEach(edge => {
            network.body.data.edges.update({ id: edge.id, label: "" });
          });
        }
      }
			function applyLayoutPhysics() {
				const layoutType = document.getElementById("layoutType").value;
				const physicsModel = document.getElementById("physicsModel").value;
				let layoutOption = layoutType === "hierarchical" ?
					{ hierarchical: { enabled: true, direction: "LR", sortMethod: "directed", edgeMinimization: true } } :
					{ hierarchical: { enabled: false } };
				let physicsOption = {};
				if (physicsModel !== "disabled") {
					physicsOption = { enabled: true, solver: physicsModel };
					switch (physicsModel) {
						case "barnesHut":
							physicsOption.barnesHut = { theta: 0.5, gravitationalConstant: -2000, centralGravity: 0.3, springLength: 95, springConstant: 0.04, damping: 0.09, avoidOverlap: 0 };
							break;
						case "forceAtlas2Based":
							physicsOption.forceAtlas2Based = { theta: 0.5, gravitationalConstant: -50, centralGravity: 0.01, springLength: 100, springConstant: 0.08, damping: 0.4, avoidOverlap: 0 };
							break;
						case "repulsion":
							physicsOption.repulsion = { centralGravity: 0.2, springLength: 200, springConstant: 0.05, nodeDistance: 100, damping: 0.09 };
							break;
						case "hierarchicalRepulsion":
							physicsOption.hierarchicalRepulsion = { centralGravity: 0.0, springLength: 100, springConstant: 0.01, nodeDistance: 120, damping: 0.09, avoidOverlap: 0 };
							break;
						default:
							break;
					}
					physicsOption.stabilization = { enabled: true, iterations: 1000, updateInterval: 100, fit: true };
					physicsOption.timestep = 0.5;
					physicsOption.adaptiveTimestep = true;
				} else {
					physicsOption = { enabled: false };
				}
				networkNodes.get().forEach(function (node) {});
				network.setOptions({ layout: layoutOption, physics: physicsOption });
			}

			document.getElementById("expandAllButton").addEventListener("click", function () {
        network.body.data.nodes.get().forEach(function(node) {
          if (!nodeState[node.id] || !nodeState[node.id].expanded) {
            expandNode(node.id);
            nodeState[node.id] = nodeState[node.id] || {};
            nodeState[node.id].expanded = true;
            nodeState[node.id].baseLabel = nodeState[node.id].baseLabel || node.label.replace(/\s[\[\]\+\-]+$/, '');
            network.body.data.nodes.update({ id: node.id, label: nodeState[node.id].baseLabel + " [-]" });
          }
        });
      });

			document.getElementById("resetViewButton").addEventListener("click", function () {
				if (network) network.fit();
			});

			document.getElementById("exportSVGButton").addEventListener("click", function () {
				exportSVG();
			});
      document.getElementById("exportDOTButton").addEventListener("click", function () {
				exportDOT();
			});

      function exportDOT() {
        let dotStr = "digraph G {\n";
        networkNodes.get().forEach(node => {
          dotStr += `  "${node.id}" [label="${node.label}"];\n`;
        });
        networkEdges.get().forEach(edge => {
          // Only include a label if available
          const label = edge.label ? ` [label="${edge.label}"]` : "";
          dotStr += `  "${edge.from}" -> "${edge.to}"${label};\n`;
        });
        dotStr += "}\n";
        
        const blob = new Blob([dotStr], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const downloadLink = document.createElement("a");
        downloadLink.href = url;
        downloadLink.download = "graph.dot";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      }
      // Synchronize the physics configuration between the config box and sidebar select.
      function syncConfigToSidebar() {
        // Find the physics enabled checkbox inside the config box.
        // (Assuming the first vis-config-checkbox corresponds to physics enabled.)
        const physicsCheckbox = document.querySelector("#configBoxContent input.vis-config-checkbox");
        // Find the solver select element inside the config box.
        const solverSelect = document.querySelector("#configBoxContent select.vis-config-select");
        // Get the sidebar physics model select.
        const sidebarPhysicsSelect = document.getElementById("physicsModel");

        if (physicsCheckbox && solverSelect && sidebarPhysicsSelect) {
          if (!physicsCheckbox.checked) { 
            // Physics is disabled; update the sidebar accordingly.
            sidebarPhysicsSelect.value = "disabled";
            sidebarPhysicsSelect.disabled = true;
          } else {
            sidebarPhysicsSelect.disabled = false;
            // If physics is enabled, sync the selected solver from the config box.
            sidebarPhysicsSelect.value = solverSelect.value;
          }
        }
      }

      // Listen for changes in the config box (generated by vis-network)
      document.getElementById("configBoxContent").addEventListener("change", function () {
        // Re-render or update your network as needed.
        renderGraph();
        // Sync the sidebar values.
        syncConfigToSidebar();
      });

      // Listen for changes on the sidebar physics model select.
      document.getElementById("physicsModel").addEventListener("change", function () {
        const sidebarValue = this.value;
        // Find the corresponding controls inside the config box.
        const physicsCheckbox = document.querySelector("#configBoxContent input.vis-config-checkbox");
        const solverSelect = document.querySelector("#configBoxContent select.vis-config-select");

        if (physicsCheckbox && solverSelect) {
          if (sidebarValue === "disabled") {
            // Uncheck the physics checkbox if the sidebar select is set to "disabled".
            physicsCheckbox.checked = false;
            // Trigger change event to propagate the update.
            physicsCheckbox.dispatchEvent(new Event("change"));
          } else {
            // Enable physics by checking the checkbox.
            physicsCheckbox.checked = true;
            // Set the solver select in the config box to match the sidebar.
            solverSelect.value = sidebarValue;
            // Trigger change events on both elements.
            physicsCheckbox.dispatchEvent(new Event("change"));
            solverSelect.dispatchEvent(new Event("change"));
          }
        }
      });
      // Listen for changes on the physics enabled checkbox in the config box.
      document.addEventListener("change", function(e) {
        if (e.target.matches("#configBoxContent input.vis-config-checkbox")) {
          const isEnabled = e.target.checked;
          const sidebarPhysicsSelect = document.getElementById("physicsModel");
          if (isEnabled) {
            sidebarPhysicsSelect.disabled = false;
            const solverSelect = document.querySelector("#configBoxContent select.vis-config-select");
            sidebarPhysicsSelect.value = solverSelect ? solverSelect.value : "barnesHut";
          } else {
            sidebarPhysicsSelect.disabled = true;
            sidebarPhysicsSelect.value = "disabled";
          }
          renderGraph();
        }
      });


		</script>
	</body>
</html>
