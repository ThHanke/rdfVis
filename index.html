<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Interactive RDF Graph Visualizer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- Include full d3 library first -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Then include d3-scale-chromatic -->
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <style>
      #content {
        height: calc(100vh - 56px); /* Adjust height based on navbar height */
      }
      #contentrow {
        height: 100%; /* Set row height to 100% of the container */
        overflow: auto; /* Manage overflow content */
      }
      #sidebar {
          transition: margin 0.3s;
      }
      .sidebar.hidden {
        transform: translateX(-250px);
        margin-left: -250px; /* Adjust this value based on your sidebar width */
      }
      
      .container-fluid.expanded {
        margin-left: 0;
      }
  
      /* Legend styling – fixed to lower right of the viewport */      
      #legendResizeHandle {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 15px;
        height: 15px;
        cursor: se-resize;
        background: rgba(0, 0, 0, 0.2);
      }
      #legend {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 220px; /* Default width */
        max-height: 300px; /* Keep a max-height */
        overflow: hidden; /* Prevent overflow */
        z-index: 1001;
        cursor: move;
        resize: both; /* Enable browser native resize if supported */
      }
      
      #legend .row {
          overflow: hidden; /* Prevent horizontal scrolling */
      }
      
      .legend-text {
          white-space: nowrap; /* Prevent text from wrapping */
          overflow: hidden; /* Hide overflow */
          text-overflow: ellipsis; /* Add ellipsis for long text */
      }
      
      #legend .legend-color {
        width: 15px;
        height: 15px;
        margin-right: 10px; /* Space between color box and prefix */
      }
      
      #legend .legend-prefix {
          flex: 1; /* Allow the prefix to take remaining space */
          white-space: nowrap; /* Prevent text from wrapping */
      }
        
      /* Configuration Box Styling */
      #configBox {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 300px;
        background-color: #ffffff;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 1001;
        display: none; /* Hidden by default */
        flex-direction: column;
      }
  
      #configBox.hidden {
        height: 40px;
        overflow: hidden;
      }
  
      #configBoxHeader {
        background-color: #f1f1f1;
        padding: 10px;
        cursor: move;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #dee2e6;
      }
  
      #configBoxContent {
        padding: 10px;
        overflow-y: auto;
        max-height: 400px; /* Set a maximum height */
      }
  
      #minimizeBtn {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
      }
      #mainContent {
        position: relative;
      }
      /* Adjust graph container to account for floating boxes */
      #graphContainer {
        height: calc(100vh - 56px);
        width: 100%;
        position: relative;
      }
      
      @media (max-width: 767.98px) {
        #mainContent {
          margin-top: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <div class="container-fluid">
        <button id="toggleSidebar" class="btn btn-sm me-2">☰</button>
        <a class="navbar-brand" href="#">Interactive RDF Graph Visualizer</a>
        <div class="ms-auto">
          <button id="toggleLegend" class="btn btn-secondary btn-sm ms-2">Legend</button>
          <button id="toggleConfigBox" class="btn btn-secondary btn-sm">Physics</button>
        </div>
      </div>
    </nav>
    <div class="container-fluid" id="content">
        <div class="row" id="contentrow">
            <!-- Sidebar -->
            <div class="sidebar col-12 col-md-3 col-xl-2 px-0 bg-light d-flex flex-column" id="sidebar">
              <h5>RDF Graph Visualizer</h5>
              <hr />
              <!-- Input Source -->
              <div class="mb-3">
                <label class="form-label">Input Source</label>
                <div class="form-check">
                  <input class="form-check-input" type="radio" name="inputType" id="fileInputRadio" checked />
                  <label class="form-check-label" for="fileInputRadio">Load from File</label>
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="radio" name="inputType" id="sparqlInputRadio" />
                  <label class="form-check-label" for="sparqlInputRadio">Load from SPARQL Endpoint</label>
                </div>
              </div>
              <!-- File Input Section -->
              <div id="fileSection" class="mb-3">
                <input type="file" id="fileInput" accept=".ttl,.txt" class="form-control" />
                <button id="loadFileButton" class="btn btn-primary btn-sm mt-2">Load RDF Graph</button>
                
                <div class="mt-3">
                  <label class="form-label">Or enter file URL:</label>
                  <input type="text" id="fileUrlInput" placeholder="http://example.org/data.ttl" value="https://raw.githubusercontent.com/Mat-O-Lab/IOFMaterialsTutorial/refs/heads/main/sieving_ASTM_B214-07.ttl" class="form-control" />
                  <button id="loadFileUrlButton" class="btn btn-primary btn-sm mt-2">Load RDF from URL</button>
                </div>
              </div>                
              <!-- SPARQL Input Section -->
              <div id="sparqlSection" class="mb-3" style="display: none;">
                <div class="mb-2">
                  <label for="endpointUrl" class="form-label">Endpoint URL:</label>
                  <input type="text" id="endpointUrl" class="form-control" placeholder="https://example.org/sparql" />
                </div>
                <div class="mb-2">
                  <label for="sparqlQuery" class="form-label">SPARQL Query (CONSTRUCT):</label>
                  <textarea id="sparqlQuery" class="form-control" rows="3">
        CONSTRUCT { ?s ?p ?o } WHERE { ?s ?p ?o } LIMIT 100
                  </textarea>
                </div>
                <button id="loadSparqlButton" class="btn btn-primary btn-sm">Load SPARQL Graph</button>
              </div>
              <hr />
              <!-- Layout & Display Options -->
              <div class="mb-3">
                <h6>Layout Options</h6>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="disableImprovedLayout" />
                  <label class="form-check-label" for="disableImprovedLayout">Disable Improved Layout</label>
                </div>
                <div class="mb-2">
                  <label for="layoutType" class="form-label">Layout Type:</label>
                  <select id="layoutType" class="form-select form-select-sm">
                    <option value="force">Force Directed</option>
                    <option value="hierarchical" selected>Hierarchical</option>
                  </select>
                </div>
                <div class="mb-2">
                  <label for="connectionStyle" class="form-label">Connection Style:</label>
                  <select id="connectionStyle" class="form-select form-select-sm">
                    <option value="curved" selected>Curved</option>
                    <option value="straight">Straight</option>
                  </select>
                </div>
                <div class="mb-2">
                  <label for="physicsModel" class="form-label">Physics Model:</label>
                  <select id="physicsModel" class="form-select form-select-sm">
                    <option value="barnesHut">Barnes-Hut</option>
                    <option value="forceAtlas2Based">Force Atlas 2 Based</option>
                    <option value="repulsion">Repulsion</option>
                    <option value="hierarchicalRepulsion">Hierarchical Repulsion</option>
                    <option value="disabled" selected>Disabled</option>
                  </select>
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="hideIsolatedNodes" checked />
                  <label class="form-check-label" for="hideIsolatedNodes">Hide Isolated Nodes</label>
                </div>
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="displayEdgeLabels" checked />
                  <label class="form-check-label" for="displayEdgeLabels">Display Edge Labels</label>
                </div>
                <div class="d-flex flex-wrap gap-1 mt-2">
                  <button id="expandAllButton" class="btn btn-secondary btn-sm">Expand All</button>
                  <button id="resetViewButton" class="btn btn-secondary btn-sm">Reset View</button>
                  <button id="exportSVGButton" class="btn btn-secondary btn-sm">Export SVG</button>
                  <button id="exportDOTButton" class="btn btn-secondary btn-sm">Export DOT</button>
                </div>
              </div>
              <hr />
              <footer class="mt-auto">
                <small>
                  Source code available at
                  <a href="https://github.com/ThHanke/rdfVis" target="_blank">GitHub</a>
                </small>
              </footer>
            </div>

            <!-- Main Content -->
            <main class="col-12 col-md-9 col-xl-10 px-4" id="mainContent">
              <div id="errorContainer" class="text-danger w-100"></div>
              <div id="contentArea">
                <!-- Graph Container -->
                <div id="graphContainer" class="mt-3">
                  <!-- Graph renders here -->
                </div>
                <!-- Configuration Box floating at top left -->
                <div id="configBox">
                  <div id="configBoxHeader">
                    <span>Configuration</span>
                    <button id="minimizeBtn">&minus;</button>
                  </div>
                  <div id="configBoxContent">
                    <!-- vis-network configuration controls will appear here -->
                  </div>
                </div>
                <!-- Moveable Legend Box -->
                <div id="legend" class="card">
                  <div class="card-header">Legend</div>
                  <div class="container" id="legendList"></ul>
                  <div id="legendResizeHandle"></div>
                </div>
              </div>
            </main>
        </div>
    </div>
		<!-- Bootstrap Bundle with Popper -->
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
		<!-- vis-network -->
		<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
		<!-- rdflib -->
		<script src="https://unpkg.com/rdflib@2.2.4/dist/rdflib.min.js"></script>

    <script>
      // Sidebar Toggle Functionality
    const toggleBtn = document.getElementById("toggleSidebar");
    const sidebar = document.getElementById("sidebar");
    const mainContent = document.getElementById("mainContent");

    toggleBtn.addEventListener("click", () => {
      sidebar.classList.toggle("hidden");
      mainContent.classList.toggle("expanded");
    });

    // Configuration Box Minimize/Restore Functionality
    const minimizeBtn = document.getElementById("minimizeBtn");
    const configBox = document.getElementById("configBox");
    const configBoxContent = document.getElementById("configBoxContent");
    let isConfigMinimized = false;

    minimizeBtn.addEventListener("click", () => {
      isConfigMinimized = !isConfigMinimized;
      if (isConfigMinimized) {
        configBox.classList.add("hidden");
        minimizeBtn.innerHTML = "+";
      } else {
        configBox.classList.remove("hidden");
        minimizeBtn.innerHTML = "&minus;";
      }
    });

    // Toggle Config Box from Navbar button
    document.getElementById("toggleConfigBox").addEventListener("click", () => {
      if (configBox.style.display === "none" || configBox.style.display === "") {
        configBox.style.display = "flex";
      } else {
        configBox.style.display = "none";
      }
    });

      // Make Configuration Box Draggable
      (function makeConfigBoxDraggable() {
        const header = document.getElementById("configBoxHeader");
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

      header.onmousedown = dragMouseDown;

      function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
      }

      function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        configBox.style.top = (configBox.offsetTop - pos2) + "px";
        configBox.style.left = (configBox.offsetLeft - pos1) + "px";
      }

      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
      }
    })();
    // Toggle legend visibility when the "Legend" button is clicked.
    document.getElementById("toggleLegend").addEventListener("click", function() {
      const legend = document.getElementById("legend");
      if (legend.style.display === "none" || legend.style.display === "") {
        legend.style.display = "block";
      } else {
        legend.style.display = "none";
      }
    });

    // Make legend resizable using the custom resize handle.
    (function makeLegendResizable() {
      const legend = document.getElementById("legend");
      const resizer = document.getElementById("legendResizeHandle");
      let startX, startY, startWidth, startHeight;

      resizer.addEventListener("mousedown", function(e) {
          e.preventDefault();
          startX = e.clientX;
          startY = e.clientY;
          startWidth = parseInt(window.getComputedStyle(legend).width, 10);
          startHeight = parseInt(window.getComputedStyle(legend).height, 10);
          
          document.documentElement.addEventListener("mousemove", doDrag, false);
          document.documentElement.addEventListener("mouseup", stopDrag, false);
      });

      function doDrag(e) {
          const newWidth = Math.max(200, startWidth + e.clientX - startX); // Minimum width
          const newHeight = Math.max(100, startHeight + e.clientY - startY); // Minimum height

          legend.style.width = newWidth + "px";
          legend.style.height = newHeight + "px";
      }

      function stopDrag() {
          document.documentElement.removeEventListener("mousemove", doDrag, false);
          document.documentElement.removeEventListener("mouseup", stopDrag, false);
      }
    })();

    </script>
		<script>
			// Global variables
			var networkNodes = null;
			var networkEdges = null;
			var network = null;
      var config = {};
			var store = $rdf.graph();
      var prefixNamespaceMapping = {};
			
      const excludePredicatestoCluster = ['rdf:type','rdfs:label','dcterms:','owl:'];
      const clusteringThreshold = 10;
			var generatedPrefixCounter = 1;
			var graphData ={};     
      
			var currentNodeRadius = 15;
			var currentFontSize = 10;

      function saveConfigOptions() {
        localStorage.setItem("visNetworkConfig", JSON.stringify(config));
      }
      
      function loadConfigOptions() {
        currentNodeRadius = 15;
				currentFontSize = 10;
        
        const defaultConfig = {
          layoutType: "hierarchical",
          physicsModel: "disabled",
          connectionStyle: "curved",
          hideIsolatedNodes: true,
          displayEdgeLabels: true,
          disableImprovedLayout: false,
          visNetwork: {
            configure: {
              enabled: false,
              filter: ["physics"],
              showButton: false,
            },
            layout: { hierarchical: {
              enabled: true,
              levelSeparation: 150,
              nodeSpacing: 100,
              treeSpacing: 200,
              blockShifting: true,
              edgeMinimization: true,
              parentCentralization: true,
              direction: 'UD',        // UD, DU, LR, RL
              sortMethod: 'hubsize',  // hubsize, directed
              shakeTowards: 'leaves'  // roots, leaves
                },
              improvedLayout: true
            },
            interaction: { hover: true },
            edges: { smooth: { enabled: true, type: "continuous" } },
            nodes: {
              widthConstraint: { maximum: 100 },
              font: { multi: true, size: currentFontSize },
              shapeProperties: { useImageSize: false }
            }
          }
        };
        const configStr = localStorage.getItem("visNetworkConfig");
        let config = {};

        if (configStr) {
            config = JSON.parse(configStr);
        }
        // Merge config with defaultConfig
        const finalConfig = Object.assign({}, defaultConfig, config);

        // Set the values in the UI
        document.getElementById("layoutType").value = finalConfig.layoutType;
        document.getElementById("physicsModel").value = finalConfig.physicsModel;
        document.getElementById("connectionStyle").value = finalConfig.connectionStyle;
        document.getElementById("hideIsolatedNodes").checked = finalConfig.hideIsolatedNodes;
        document.getElementById("displayEdgeLabels").checked = finalConfig.displayEdgeLabels;
        document.getElementById("disableImprovedLayout").checked = finalConfig.disableImprovedLayout;
        return finalConfig;
      }

      //spawn worker
      let worker = new Worker("worker.js");

      // Helper: Create an SVG element with attributes.
			function createSvgElement(tag, attrs) {
				var elem = document.createElementNS("http://www.w3.org/2000/svg", tag);
				for (var key in attrs) {
					elem.setAttribute(key, attrs[key]);
				}
				return elem;
			}

			// Error display functions.
			function showError(message) {
				document.getElementById("errorContainer").innerText = message;
			}
			function clearError() {
				document.getElementById("errorContainer").innerText = "";
			}

			// Toggle input sections.
			document.getElementById("fileInputRadio").addEventListener("change", function () {
				document.getElementById("fileSection").style.display = "block";
				document.getElementById("sparqlSection").style.display = "none";
			});
			document.getElementById("sparqlInputRadio").addEventListener("change", function () {
				document.getElementById("fileSection").style.display = "none";
				document.getElementById("sparqlSection").style.display = "block";
			});
      

			
			// Helper function to perform fetch with a timeout.
      function fetchWithTimeout(url, options = {}, timeout = 10000) {
        return new Promise((resolve, reject) => {
          const controller = new AbortController();
          const timer = setTimeout(() => {
            controller.abort();
            reject(new Error("Request timed out"));
          }, timeout);

          fetch(url, { ...options, signal: controller.signal })
            .then(response => {
              clearTimeout(timer);
              resolve(response);
            })
            .catch(err => {
              clearTimeout(timer);
              reject(err);
            });
        });
      }

      function loadFromURL(sourceUrl) {
        if (sourceUrl) {
          fetchWithTimeout(sourceUrl, {}, 10000)
            .then(response => {
              if (!response.ok) {
                console.log(response)
                throw new Error("Network response was not ok: " + response.statusText);
              }
              return response.text();
            })
            .then(data => {
              localStorage.setItem("rdfData", data);
              processRDFData(data, sourceUrl, "text/turtle")
            })
            .catch(err => {
              console.error("Error fetching RDF file from source URL:", err);
            });
        }
      }
      // Load RDF data from URL parameters (source for file, sparql for SPARQL endpoint).
      function loadFromURLParameters() {
        const params = new URLSearchParams(window.location.search);
        const sourceUrl = params.get("source");
        const sparqlUrl = params.get("sparql");

        if (sourceUrl) {
          loadFromURL(sourceUrl);
        }

        if (sparqlUrl) {
          const sparqlQuery = params.get("query") || "CONSTRUCT { ?s ?p ?o } WHERE { ?s ?p ?o } LIMIT 100";
          fetchWithTimeout(sparqlUrl, {
            method: "POST",
            headers: { "Content-Type": "application/sparql-query", "Accept": "text/turtle" },
            body: sparqlQuery
          }, 10000)
            .then(response => {
              if (!response.ok) {
                throw new Error("Network response was not ok: " + response.statusText);
              }
              return response.text();
            })
            .then(data => {
              processRDFData(data, sourceUrl, "text/turtle")
            })
            .catch(err => {
              console.error("Error fetching SPARQL data from URL parameter:", err);
            });
        }
      }

      function processRDFData(rdfData, baseUrl, contentType) {
        worker.postMessage({
          action: "parse",
          rdfData: rdfData,
          baseUrl: baseUrl,
          contentType: contentType,
        });
      }

      worker.onmessage = function (event) {
        if (event.data.status === "success") {
          graphData=event.data.graphData;
          renderNetwork();
        } else if (event.data.status === "error") {
          console.log(event.data)
          showError("Error processing RDF: " + event.data.error);
        }
      };
      

      function updateLegend(prefixColorMapping) {
        var legendContainer = document.getElementById("legendList");
        legendContainer.innerHTML = ""; // Clear previous legend
    
        for (const prefix in prefixColorMapping) {
            if (prefixColorMapping.hasOwnProperty(prefix)) {
                const { uri, color } = prefixColorMapping[prefix];

                const rowItem = document.createElement("div");
                rowItem.classList.add("row");
                
                const leftContainer = document.createElement("div");
                leftContainer.classList.add("col-12", "col-md-6");
    
                const colorBox = document.createElement("span");
                colorBox.classList.add("legend-color");
                colorBox.style.backgroundColor = color;
                colorBox.style.width = "15px";
                colorBox.style.height = "15px";
                colorBox.style.display = "inline-block";
                colorBox.style.marginRight = "10px";
                colorBox.style.border = "1px solid #000";
    
                const prefixLabel = document.createElement("span");
                prefixLabel.innerText = prefix;
                prefixLabel.classList.add("fw-bold", "legend-prefix");
    
                leftContainer.appendChild(colorBox);
                leftContainer.appendChild(prefixLabel);
                rowItem.appendChild(leftContainer);
    
                const uriText = document.createElement("div");
                uriText.innerText = uri;
                uriText.classList.add("col-12", "col-md-6", "text-muted", "small","legend-text");

                rowItem.appendChild(uriText);
                
                legendContainer.appendChild(rowItem);
            }
        }
      }    
      
			// Render network with options.
			function renderNetwork() {
        console.log(graphData)
        var connectedIds = new Set();
        var nodes = {};
        var connections = {};
        const configBoxContent = document.getElementById("configBoxContent");
        config.visNetwork.configure.container=configBoxContent;
        config.visNetwork.configure.enabled=true;
        console.log(config)
        graphData.network.edges.forEach(function (edge) {
          connectedIds.add(edge.from);
          connectedIds.add(edge.to);
        });
        if (config.hideIsolatedNodes) {  
          networkNodes = new vis.DataSet(graphData.network.nodes.filter(function (n) { return connectedIds.has(n.id); }));
        } else {
          networkNodes = new vis.DataSet(graphData.network.nodes);
        }
				networkEdges = new vis.DataSet(graphData.network.edges);
				networkNodes.forEach(function (node) {
					node.size = currentNodeRadius;
					networkNodes.update(node);
				});
        if (!config.displayEdgeLabels) {
          networkEdges.forEach(function (edge) {
            edge.label = "";
          });
        } else {
          networkEdges.forEach(function (edge) {
            edge.label = edge.baseLabel;
          });
        }
        
				if (network) network.destroy();
				network = new vis.Network(document.getElementById("graphContainer"), { nodes: networkNodes, edges: networkEdges }, config.visNetwork);
				network.on("doubleClick", function (params) {
          if (params.nodes.length === 1) {
            const nodeId = params.nodes[0];
            if (network.isCluster(nodeId)) {
              network.openCluster(nodeId);
            } else {
              toggleNode(nodeId);
            }
          }
        });

        // Apply clustering
        applyClusteringByPredicate();
        applyEdgeFormat();
        applyLayoutPhysics();
        updateLegend(graphData.prefixColorMapping)
			}
      
      // List of predicates to include in clustering
      
      function applyClusteringByPredicate() {
        const predicateLabels = new Set();

        networkEdges.get().forEach(edge => {
          if (edge.label) {
            // Include only predicates in the includedPredicates array
            if (excludePredicatestoCluster.some(pred => edge.label.includes(pred))) return;
            predicateLabels.add(edge.label);
          }
        });

        predicateLabels.forEach(predicateLabel => {
          clusterNodesByPredicate(predicateLabel);
        });
      }
      
      function clusterNodesByPredicate(predicateLabel) {
        const clusterOptions = {
          joinCondition: function(nodeOptions) {
            const connectedEdges = network.getConnectedEdges(nodeOptions.id);
            const count = connectedEdges.filter(edgeId => {
              const edge = network.body.data.edges.get(edgeId);
              return edge.label === predicateLabel;
            }).length;
            // Only include nodes with connections exceeding the threshold
            return count > clusteringThreshold;
          },
          processProperties: function(clusterOptions, childNodes, childEdges) {
            clusterOptions.label = predicateLabel + "\n(" + childNodes.length + " nodes)";
            clusterOptions.shape = "circle";
            clusterOptions.color = { background: '#FFC107', border: '#FF9800' }; // Customize color
            clusterOptions.title = "Cluster of nodes connected via predicate: " + predicateLabel;
            return clusterOptions;
          },
          clusterNodeProperties: { id: 'cluster:' + predicateLabel, borderWidth: 3, shape: 'circle' }
        };
      
        network.cluster(clusterOptions);
      }
			// Toggle node expansion/collapse
			function toggleNode(nodeId) {
        const node = graphData.network.nodes.find(node => node.id === nodeId);
        console.log(nodeId);
        console.log(node);
        if (!node) return;

        if (node.expanded) {
          collapseNode(nodeId);
          node.expanded = false;
          network.body.data.nodes.update({ id: nodeId, label: node.baseLabel + " [+]" });
        } else {
          expandNode(nodeId);
          node.expanded = true;
          network.body.data.nodes.update({ id: nodeId, label: node.baseLabel + " [-]" });
        }
      }

			function collapseNode(nodeId) {
        // Fetch all outgoing edges from this node
        var connectedEdges = network.getConnectedEdges(nodeId);
      
        connectedEdges.forEach(function(edgeId) {
          var edge = network.body.data.edges.get(edgeId);
          if (edge.from === nodeId) {
            // Hide the edge
            network.body.data.edges.update({ id: edgeId, hidden: true });
            // Hide the connected node if it's not connected elsewhere
            var connectedNodeId = edge.to;
      
            // Check if the connected node has other visible incoming edges
            var incomingEdges = network.getConnectedEdges(connectedNodeId).filter(function(eid) {
              var e = network.body.data.edges.get(eid);
              return e.to === connectedNodeId && !e.hidden && e.from !== nodeId;
            });
      
            if (incomingEdges.length === 0) {
              // Recursively collapse the connected node
              collapseNode(connectedNodeId);
              network.body.data.nodes.update({ id: connectedNodeId, hidden: true });
              // Ensure nodeState exists before updating
              const connNode = graphData.network.nodes.find(node => node.id === connectedNodeId);
              if (connNode) {
                connNode.expanded = false;
              }
            }
          }
        });
      }

			function expandNode(nodeId) {
        // Fetch all outgoing edges from this node
        var connectedEdges = network.getConnectedEdges(nodeId);
      
        connectedEdges.forEach(function(edgeId) {
          var edge = network.body.data.edges.get(edgeId);
          if (edge.from === nodeId) {
            // Show the edge
            network.body.data.edges.update({ id: edgeId, hidden: false });
            // Show the connected node
            var connectedNodeId = edge.to;
            network.body.data.nodes.update({ id: connectedNodeId, hidden: false });
          }
        });
      }

			// Make legend draggable
			(function makeLegendDraggable() {
				var legend = document.getElementById("legend");
				var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
				legend.onmousedown = dragMouseDown;
				function dragMouseDown(e) {
					e = e || window.event;
					e.preventDefault();
					pos3 = e.clientX;
					pos4 = e.clientY;
					document.onmouseup = closeDragElement;
					document.onmousemove = elementDrag;
				}
				function elementDrag(e) {
					e = e || window.event;
					e.preventDefault();
					pos1 = pos3 - e.clientX;
					pos2 = pos4 - e.clientY;
					pos3 = e.clientX;
					pos4 = e.clientY;
					legend.style.top = (legend.offsetTop - pos2) + "px";
					legend.style.left = (legend.offsetLeft - pos1) + "px";
				}
				function closeDragElement() {
					document.onmouseup = null;
					document.onmousemove = null;
				}
			})();

			// Export SVG helper function for element creation.
			function createSvgElement(tag, attrs) {
				var elem = document.createElementNS("http://www.w3.org/2000/svg", tag);
				for (var key in attrs) {
					elem.setAttribute(key, attrs[key]);
				}
				return elem;
			}

			// Export current view as SVG.
			function exportSVG() {
				const container = document.getElementById("graphContainer");
				const width = container.clientWidth;
				const height = container.clientHeight;
				const svgNS = "http://www.w3.org/2000/svg";
				const svgElem = createSvgElement("svg", { width: width, height: height, xmlns: svgNS });
				const defs = createSvgElement("defs", {});
				const marker = createSvgElement("marker", {
					id: "arrow",
					markerWidth: "10",
					markerHeight: "10",
					refX: "10",
					refY: "3",
					orient: "auto",
					markerUnits: "strokeWidth"
				});
				const arrowPath = createSvgElement("path", { d: "M0,0 L0,6 L9,3 z", fill: "#000" });
				marker.appendChild(arrowPath);
				defs.appendChild(marker);
				svgElem.appendChild(defs);
				const positions = network.getPositions();
				networkEdges.get().forEach(function (edge) {
					if (edge.hidden) return;
					const fromPos = positions[edge.from];
					const toPos = positions[edge.to];
					if (!fromPos || !toPos) return;
					const line = createSvgElement("line", {
						x1: fromPos.x,
						y1: fromPos.y,
						x2: toPos.x,
						y2: toPos.y,
						stroke: "#000",
						"stroke-width": "2",
						"marker-end": "url(#arrow)"
					});
					svgElem.appendChild(line);
					if (document.getElementById("displayEdgeLabels").checked && edge.label) {
						const midX = (fromPos.x + toPos.x) / 2;
						const midY = (fromPos.y + toPos.y) / 2;
						const text = createSvgElement("text", {
							x: midX,
							y: midY,
							"font-size": "10",
							fill: "#000",
							"text-anchor": "middle"
						});
						text.textContent = shortenLabel(edge.label);
						svgElem.appendChild(text);
					}
				});
				networkNodes.get().forEach(function (node) {
					if (node.hidden) return;
					const pos = positions[node.id];
					if (!pos) return;
					if (node.shape === "circle") {
						const radius = node.size || currentNodeRadius;
						const circle = createSvgElement("circle", {
							cx: pos.x,
							cy: pos.y,
							r: radius,
							fill: node.color && node.color.background ? node.color.background : "#CCCCCC",
							stroke: node.color && node.color.border ? node.color.border : "#000",
							"stroke-width": "2"
						});
						svgElem.appendChild(circle);
					} else {
						const rect = createSvgElement("rect", {
							x: pos.x - currentNodeRadius,
							y: pos.y - currentNodeRadius,
							width: currentNodeRadius * 2,
							height: currentNodeRadius * 2,
							fill: node.color && node.color.background ? node.color.background : "#CCCCCC",
							stroke: node.color && node.color.border ? node.color.border : "#000",
							"stroke-width": "2"
						});
						svgElem.appendChild(rect);
					}
					const text = createSvgElement("text", {
						x: pos.x,
						y: pos.y + 4,
						"font-size": currentFontSize,
						fill: "#000",
						"text-anchor": "middle"
					});
					text.textContent = nodeState[node.id] ? nodeState[node.id].baseLabel : node.label;
					svgElem.appendChild(text);
				});
				const legend = document.getElementById("legend");
				const legendRect = legend.getBoundingClientRect();
				const graphRect = document.getElementById("graphContainer").getBoundingClientRect();
				const legendGroup = createSvgElement("g", {});
				legendGroup.setAttribute("transform", `translate(${legendRect.left - graphRect.left}, ${legendRect.top - graphRect.top})`);
				const legendBg = createSvgElement("rect", {
					x: 0,
					y: 0,
					width: legendRect.width,
					height: legendRect.height,
					fill: "#fff",
					stroke: "#000"
				});
				legendGroup.appendChild(legendBg);
				const legendItems = document.getElementById("legendList").children;
				for (let i = 0; i < legendItems.length; i++) {
					const item = legendItems[i];
					const color = item.querySelector(".legend-color").style.background;
					const prefix = item.querySelector("strong").innerText;
					let ns = "";
					for (const k in knownPrefixes) {
						const displayKey = (k === "" ? "base" : k);
						if (displayKey === prefix) {
							ns = knownPrefixes[k];
							break;
						}
					}
					const colorRect = createSvgElement("rect", {
						x: 5,
						y: 5 + i * 25,
						width: 15,
						height: 15,
						fill: color,
						stroke: "#000"
					});
					legendGroup.appendChild(colorRect);
					const prefixText = createSvgElement("text", {
						x: 25,
						y: 17 + i * 25,
						"font-size": "10",
						fill: "#000"
					});
					prefixText.textContent = prefix;
					legendGroup.appendChild(prefixText);
					const nsText = createSvgElement("text", {
						x: 5,
						y: 25 + i * 25,
						"font-size": "8",
						fill: "#555"
					});
					nsText.textContent = ns;
					legendGroup.appendChild(nsText);
				}
				svgElem.appendChild(legendGroup);
				const serializer = new XMLSerializer();
				const svgString = serializer.serializeToString(svgElem);
				const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
				const url = URL.createObjectURL(blob);
				const downloadLink = document.createElement("a");
				downloadLink.href = url;
				downloadLink.download = "graph.svg";
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);
			}

      document.getElementById("loadFileButton").addEventListener("click", function () {
        clearError();
        const fileInput = document.getElementById("fileInput");
        if (fileInput.files.length === 0) {
          showError("Please select a file.");
          return;
        }
        const file = fileInput.files[0];
        const reader = new FileReader();
        reader.onerror = function (e) {
          showError("Error reading file: " + e.target.error.message);
        };
        reader.onload = function (e) {
          const data = e.target.result;
          localStorage.setItem("rdfData", data);
          processRDFData(data, "http://file.local/", "text/turtle");
        };
        reader.readAsText(file);
      });
    
      document.getElementById("loadFileUrlButton").addEventListener("click", function () {
        clearError();
        const fileUrl = document.getElementById("fileUrlInput").value.trim();
        if (!fileUrl) {
          showError("Please enter a file URL.");
          return;
        }
        fetch(fileUrl)
          .then(response => {
            if (!response.ok) {
              throw new Error("Network error: " + response.statusText);
            }
            return response.text();
          })
          .then(data => {
            localStorage.setItem("rdfData", data);
            processRDFData(data, fileUrl, "text/turtle");
          })
          .catch(err => {
            showError("Error fetching RDF file: " + err.message);
          });
      });
    
      document.getElementById("loadSparqlButton").addEventListener("click", function () {
        clearError();
        const endpointUrl = document.getElementById("endpointUrl").value.trim();
        const query = document.getElementById("sparqlQuery").value.trim();
        if (!endpointUrl || !query) {
          showError("Please provide both an endpoint URL and a SPARQL query.");
          return;
        }
        fetch(endpointUrl, {
          method: "POST",
          headers: { "Content-Type": "application/sparql-query", "Accept": "text/turtle" },
          body: query,
        })
          .then(response => {
            if (!response.ok) {
              throw new Error("Network error: " + response.statusText);
            }
            return response.text();
          })
          .then(data => {
            processRDFData(data, endpointUrl, "text/turtle");
          })
          .catch(err => {
            showError("Error fetching SPARQL data: " + err.message);
          });
      });
    
      window.onload = function () {
        config = loadConfigOptions();
        clearError();
        const savedData = localStorage.getItem("rdfData");
        if (savedData) {
          processRDFData(savedData, "http://example.org/", "text/turtle");
        }
      };
      

      document.getElementById("layoutType").addEventListener("change", function() {
        config.layoutType=document.getElementById("layoutType").value;
        saveConfigOptions();
        applyLayoutPhysics();
        renderNetwork();
      });
    
      document.getElementById("physicsModel").addEventListener("change", function() {
        config.layoutType=document.getElementById("physicsModel").value;
        saveConfigOptions();
        applyLayoutPhysics();
        renderNetwork();
      });
    
      document.getElementById("connectionStyle").addEventListener("change", function() {
        var connectionStyle = document.getElementById("connectionStyle").value;
				var smoothOption = connectionStyle === "curved" ? { enabled: true, type: "continuous" } : false;
        config.connectionStyle=connectionStyle;
        config.visNetwork.edges={ smooth: smoothOption};
        saveConfigOptions();
        renderNetwork();
      });
    
      document.getElementById("hideIsolatedNodes").addEventListener("change", function() {
        config.hideIsolatedNodes = document.getElementById("hideIsolatedNodes").checked;
        saveConfigOptions();
        renderNetwork();
      });
    
      document.getElementById("displayEdgeLabels").addEventListener("change", function() {
        config.displayEdgeLabels = document.getElementById("displayEdgeLabels").checked;
        saveConfigOptions();
        renderNetwork();
      });
    
      document.getElementById("disableImprovedLayout").addEventListener("change", function() {
        config.disableImprovedLayout = document.getElementById("disableImprovedLayout").checked
        config.visNetwork.layout.improvedLayout=!document.getElementById("disableImprovedLayout").checked;
        saveConfigOptions();
        renderNetwork();
      });
    
      // Also save when the configuration box (generated by vis‑network) changes
      document.getElementById("configBoxContent").addEventListener("change", function() {
        syncConfigToSidebar();
        saveConfigOptions();
        renderNetwork();
      });

      function applyEdgeFormat() {
        const displayEdgeLabels = document.getElementById("displayEdgeLabels").checked;
        if (!displayEdgeLabels) {
          network.body.data.edges.forEach(edge => {
            network.body.data.edges.update({ id: edge.id, label: "" });
          });
        }
      }
			function applyLayoutPhysics() {
				const layoutType = document.getElementById("layoutType").value;
				const physicsModel = document.getElementById("physicsModel").value;
				let layoutOption = layoutType === "hierarchical" ?
					{ hierarchical: { enabled: true, direction: "LR", sortMethod: "directed", edgeMinimization: true } } :
					{ hierarchical: { enabled: false } };
				let physicsOption = {};
				if (physicsModel !== "disabled") {
					physicsOption = { enabled: true, solver: physicsModel };
					switch (physicsModel) {
						case "barnesHut":
							physicsOption.barnesHut = { theta: 0.5, gravitationalConstant: -2000, centralGravity: 0.3, springLength: 95, springConstant: 0.04, damping: 0.09, avoidOverlap: 0 };
							break;
						case "forceAtlas2Based":
							physicsOption.forceAtlas2Based = { theta: 0.5, gravitationalConstant: -50, centralGravity: 0.01, springLength: 100, springConstant: 0.08, damping: 0.4, avoidOverlap: 0 };
							break;
						case "repulsion":
							physicsOption.repulsion = { centralGravity: 0.2, springLength: 200, springConstant: 0.05, nodeDistance: 100, damping: 0.09 };
							break;
						case "hierarchicalRepulsion":
							physicsOption.hierarchicalRepulsion = { centralGravity: 0.0, springLength: 100, springConstant: 0.01, nodeDistance: 120, damping: 0.09, avoidOverlap: 0 };
							break;
						default:
							break;
					}
					physicsOption.stabilization = { enabled: true, iterations: 1000, updateInterval: 100, fit: true };
					physicsOption.timestep = 0.5;
					physicsOption.adaptiveTimestep = true;
				} else {
					physicsOption = { enabled: false };
				}
				networkNodes.get().forEach(function (node) {});
				network.setOptions({ layout: layoutOption, physics: physicsOption });
			}

			document.getElementById("expandAllButton").addEventListener("click", function () {
        const collapsedNodes = graphData.network.nodes.filter(node => node.expanded === false);
        collapsedNodes.forEach(node => {
          expandNode(node.id);
          network.body.data.nodes.update({ id: node.id, label: node.baseLabel + " [-]" });
          node.expanded=true;
        });
      });

			document.getElementById("resetViewButton").addEventListener("click", function () {
				if (network) network.fit();
			});

			document.getElementById("exportSVGButton").addEventListener("click", function () {
				exportSVG();
			});
      document.getElementById("exportDOTButton").addEventListener("click", function () {
				exportDOT();
			});

      function exportDOT() {
        let dotStr = "digraph G {\n";
        networkNodes.get().forEach(node => {
            // Extract the text between <b></b> tags using regex
            const labelMatch = node.label.match(/<b>(.*?)<\/b>/);
            const labelText = labelMatch ? labelMatch[1] : node.label; // Fallback to original label if no match
            dotStr += `  "${node.id}" [label="${labelText}"];\n`;
        });
        networkEdges.get().forEach(edge => {
            // Only include a label if available
            const label = edge.label ? ` [label="${edge.label}"]` : "";
            dotStr += `  "${edge.from}" -> "${edge.to}"${label};\n`;
        });
        dotStr += "}\n";
    
        const blob = new Blob([dotStr], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const downloadLink = document.createElement("a");
        downloadLink.href = url;
        downloadLink.download = "graph.dot";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      }
      // Synchronize the physics configuration between the config box and sidebar select.
      function syncConfigToSidebar() {
        // Find the physics enabled checkbox inside the config box.
        // (Assuming the first vis-config-checkbox corresponds to physics enabled.)
        const physicsCheckbox = document.querySelector("#configBoxContent input.vis-config-checkbox");
        // Find the solver select element inside the config box.
        const solverSelect = document.querySelector("#configBoxContent select.vis-config-select");
        // Get the sidebar physics model select.
        const sidebarPhysicsSelect = document.getElementById("physicsModel");

        if (physicsCheckbox && solverSelect && sidebarPhysicsSelect) {
          if (!physicsCheckbox.checked) { 
            // Physics is disabled; update the sidebar accordingly.
            sidebarPhysicsSelect.value = "disabled";
            sidebarPhysicsSelect.disabled = true;
          } else {
            sidebarPhysicsSelect.disabled = false;
            // If physics is enabled, sync the selected solver from the config box.
            sidebarPhysicsSelect.value = solverSelect.value;
          }
        }
      }

      // Listen for changes in the config box (generated by vis-network)
      document.getElementById("configBoxContent").addEventListener("change", function () {
        // Re-render or update your network as needed.
        renderNetwork();
        // Sync the sidebar values.
        syncConfigToSidebar();
      });

      // Listen for changes on the sidebar physics model select.
      document.getElementById("physicsModel").addEventListener("change", function () {
        const sidebarValue = this.value;
        // Find the corresponding controls inside the config box.
        const physicsCheckbox = document.querySelector("#configBoxContent input.vis-config-checkbox");
        const solverSelect = document.querySelector("#configBoxContent select.vis-config-select");

        if (physicsCheckbox && solverSelect) {
          if (sidebarValue === "disabled") {
            // Uncheck the physics checkbox if the sidebar select is set to "disabled".
            physicsCheckbox.checked = false;
            // Trigger change event to propagate the update.
            physicsCheckbox.dispatchEvent(new Event("change"));
          } else {
            // Enable physics by checking the checkbox.
            physicsCheckbox.checked = true;
            // Set the solver select in the config box to match the sidebar.
            solverSelect.value = sidebarValue;
            // Trigger change events on both elements.
            physicsCheckbox.dispatchEvent(new Event("change"));
            solverSelect.dispatchEvent(new Event("change"));
          }
        }
      });
      // Listen for changes on the physics enabled checkbox in the config box.
      document.addEventListener("change", function(e) {
        if (e.target.matches("#configBoxContent input.vis-config-checkbox")) {
          const isEnabled = e.target.checked;
          const sidebarPhysicsSelect = document.getElementById("physicsModel");
          if (isEnabled) {
            sidebarPhysicsSelect.disabled = false;
            const solverSelect = document.querySelector("#configBoxContent select.vis-config-select");
            sidebarPhysicsSelect.value = solverSelect ? solverSelect.value : "barnesHut";
          } else {
            sidebarPhysicsSelect.disabled = true;
            sidebarPhysicsSelect.value = "disabled";
          }
          renderNetwork();
        }
      });


		</script>
	</body>
</html>
